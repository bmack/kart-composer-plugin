<?php
declare(strict_types = 1);

namespace Bmack\KartComposerPlugin;

/*
 * This file is part of Benni's Kart Composer Plugin.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that is distributed with this source code.
 */

use Composer\Composer;
use Composer\Config;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\IO\IOInterface;
use Composer\Package\RootPackageInterface;
use Composer\Plugin\PluginInterface;
use Composer\Script\Event;
use Composer\Script\ScriptEvents;
use Roave\BetterReflection\BetterReflection;
use Roave\BetterReflection\Reflector\ClassReflector;
use Roave\BetterReflection\Reflector\FunctionReflector;
use Roave\BetterReflection\SourceLocator\Type\DirectoriesSourceLocator;

/**
 * Class to check for any "extra[psr-14]" section in a composer.json of any installed
 * package to use this as searching for possible listeners.
 *
 * This then creates a class Bmack\KartComposerPlugin\ReflectionListenerProvider which
 * is used to be injected into a custom EventDispatcher for fetching listeners.
 */
class Plugin implements PluginInterface, EventSubscriberInterface
{

    /**
     * @var string
     */
    private $generatedClassTemplate = <<<'PHP'
<?php
declare(strict_types=1);
namespace Bmack\KartComposerPlugin;

/**
 * This class is generated by bmack/kart-composer-plugin
 */
final class ComposerReflectionListenerProvider implements \Psr\EventDispatcher\ListenerProviderInterface
{
    private $listeners = %s;

    /**
     * @inheritdoc
     */
    public function getListenersForEvent(object $event): iterable
    {
        $className = get_class($event);
        if (isset($this->listeners[$className])) {
            yield from $this->prepareCallable($this->listeners[$className]);
        }
        $classParents = class_parents($className);
        foreach ($classParents as $classParent) {
            if (isset($this->listeners[$classParent])) {
                yield from $this->listeners[$classParent];
            }
        }
        $classContracts = class_implements($className);
        foreach ($classContracts as $classContract) {
            if (isset($this->listeners[$classContract])) {
                yield from $this->listeners[$classContract];
            }
        }
    }
    
    private function prepareCallable($listeners)
    {
        foreach ($listeners as $args) {
            if (!isset($args[1])) {
                yield $args[0];
            } elseif ($args['isStatic']) {
                yield [$args[0], $args[1]];
            } elseif ($this->container) {
                yield [$this->container->get($args[0]), $args[1]];
            }
            yield [new $args[0], $args[1]];
        }
    }
}
PHP;

    public static function getSubscribedEvents()
    {
        return [
            ScriptEvents::PRE_AUTOLOAD_DUMP => 'findEventListeners',
        ];
    }

    /**
     * Apply plugin modifications to Composer
     *
     * @param Composer $composer
     * @param IOInterface $io
     */
    public function activate(Composer $composer, IOInterface $io)
    {
        // does nothing, see getSubscribedEvents() instead.
    }

    /**
     * Called before every dump autoload, generates a fresh PHP class.
     *
     * @param Event $event
     */
    public function findEventListeners(Event $event)
    {
        $composer = $event->getComposer();
        $listeners = $this->getRegisteredListeners($composer);

        $classContents = sprintf($this->generatedClassTemplate, var_export($listeners, true));
        $installPath = self::locateRootPackageInstallPath($composer->getConfig(), $composer->getPackage())
            . '/src/ComposerReflectionListenerProvider.php';

        file_put_contents($installPath, $classContents);
        chmod($installPath, 0664);
    }

    /**
     * Find the location where to put the generate PHP class in.
     *
     * @param Config $composerConfig
     * @param RootPackageInterface $rootPackage
     * @return string
     */
    private function locateRootPackageInstallPath(
        Config $composerConfig,
        RootPackageInterface $rootPackage
    ): string {
        // You're on your own
        if ($rootPackage->getName() === 'bmack/kart-composer-plugin') {
            return dirname($composerConfig->get('vendor-dir'));
        }
        return $composerConfig->get('vendor-dir') . '/bmack/kart-composer-plugin';
    }

    /**
     * Based on reflection, checks for [extra][psr-14] section. Currently only "default" is supported.
     *
     * @param Composer $composer
     * @return array
     */
    private function getRegisteredListeners(Composer $composer): array
    {
        $lockData = $composer->getLocker()->getLockData();
        $map = $composer->getRepositoryManager()->getLocalRepository()->getCanonicalPackages();

        $listeners = [];
        $astLocator = (new BetterReflection())->astLocator();

        foreach (array_merge($lockData['packages'], $lockData['packages-dev'] ?? []) as $k => $package) {
            $info = $package['extra']['psr-14'] ?? null;
            if ($info !== null) {
                $folder = $composer->getInstallationManager()->getInstallPath($map[$k])
                    . DIRECTORY_SEPARATOR
                    . $info['default'];
                $directoriesSourceLocator = new DirectoriesSourceLocator([$folder], $astLocator);
                $reflector = new ClassReflector($directoriesSourceLocator);
                $classes = $reflector->getAllClasses();
                foreach ($classes as $classReflection) {
                    foreach ($classReflection->getMethods() as $methodReflection) {
                        if (!$methodReflection->isPublic()) {
                            continue;
                        }
                        $param = $methodReflection->getParameters()[0];
                        $eventName = (string)$param->getType();
                        $listeners[$eventName][] = [
                            $classReflection->getName(),
                            $methodReflection->getName(),
                            'isStatic' => $methodReflection->isStatic()
                        ];
                    }
                }

                $funcReflector = new FunctionReflector($directoriesSourceLocator, $reflector);
                foreach ($funcReflector->getAllFunctions() as $funcReflection) {
                    $param = $funcReflection->getParameters()[0];
                    $eventName = (string)$param->getType();
                    $listeners[$eventName][] = [$funcReflection->getName()];
                }
            }
        }
        return $listeners;
    }
}